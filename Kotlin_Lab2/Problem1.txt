package problem1

// The below code is implemented in chronological order as Kotlin_Lab2.pdf describes

interface IDictionary{
    // ● Define an IDictionary interface for an English dictionary containing the following
    // operations: add a word, find a word and get the size of the dictionary.
    fun add(str : String) : Boolean
    fun find(str : String) : Boolean
    fun size() : Int

    // ● The dictionary’s name is a constant and should be defined using a companion object in
    // the interface.
    companion object{
        const val name : String = "Angol Szotar"
    }
}

object ListDictionary: IDictionary {
    // ● Implement the IDictionary interface in a ListDictionary class that stores the
    // words in a mutable list as shown in Fig. 1. ListDictionary should be a singleton!
    private var words = mutableListOf<String>("Dog", "Cat")

    override fun add(str: String): Boolean {
        if(str.isNotEmpty()) {
            words.add(str)
            return true
        }
        return false
    }

    override fun find(str: String): Boolean {
        return words.contains(str)
    }

    override fun size(): Int {
        return words.size
    }
}

fun main() {
    // ● Test your implementation using the following main function!
    val dict: IDictionary = ListDictionary
    println("Number of words: ${dict.size()}")
    var word: String?
    while(true){
        print("What to find? ")
        word = readLine()
        if( word.equals("quit")){
            break
        }
        println("Result: ${word?.let { dict.find(it) }}")
    }
}
